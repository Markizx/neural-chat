const Anthropic = require('@anthropic-ai/sdk');
const logger = require('../utils/logger');

class ClaudeService {
  constructor() {
    this.client = new Anthropic({
      apiKey: process.env.ANTHROPIC_API_KEY
    });
    
    this.models = {
      'claude-3.7-sonnet': 'claude-3-7-sonnet-20241022',
      'claude-4-sonnet': 'claude-sonnet-4-20250514',
      'claude-4-opus': 'claude-opus-4-20250514',
      'claude-3.5-sonnet': 'claude-3-5-sonnet-20241022',
      'claude-4-opus': 'claude-opus-4-20250514',
      'claude-4-sonnet': 'claude-sonnet-4-20250514'
    };
  }

  async createMessage(messages, options = {}) {
    try {
      const {
        model = 'claude-3.7-sonnet',
        maxTokens = 4096,
        temperature = 0.7,
        systemPrompt = null,
        stream = false
      } = options;

      const modelId = this.models[model] || model;

      const params = {
        model: modelId,
        messages: this.formatMessages(messages),
        max_tokens: maxTokens,
        temperature,
        stream
      };

      if (systemPrompt) {
        params.system = systemPrompt;
      }

      if (stream) {
        return await this.client.messages.create(params);
      }

      const response = await this.client.messages.create(params);
      
      return {
        content: response.content[0].text,
        usage: {
          promptTokens: response.usage.input_tokens,
          completionTokens: response.usage.output_tokens,
          totalTokens: response.usage.input_tokens + response.usage.output_tokens
        },
        model: modelId,
        artifacts: this.extractArtifacts(response.content[0].text)
      };
    } catch (error) {
      logger.error('Claude API error:', error);
      
      if (error.status === 429) {
        throw new Error('Rate limit exceeded. Please try again later.');
      }
      
      if (error.status === 401) {
        throw new Error('Invalid API key');
      }
      
      throw new Error(`Claude API error: ${error.message}`);
    }
  }

  async createStreamingMessage(messages, options = {}) {
    try {
      const stream = await this.createMessage(messages, { ...options, stream: true });
      return stream;
    } catch (error) {
      logger.error('Claude streaming error:', error);
      throw error;
    }
  }

  formatMessages(messages) {
    return messages.map(msg => {
      const formatted = {
        role: msg.role === 'assistant' ? 'assistant' : 'user',
        content: []
      };

      // Add text content
      if (msg.content) {
        formatted.content.push({
          type: 'text',
          text: msg.content
        });
      }

      // Add attachments
      if (msg.attachments && msg.attachments.length > 0) {
        console.log('üîç Claude processing attachments:', {
          count: msg.attachments.length,
          attachments: msg.attachments.map(att => ({
            name: att.name,
            type: att.type || att.mimeType,
            size: att.size,
            hasData: !!att.data
          }))
        });
        
        for (const attachment of msg.attachments) {
          // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —Ñ–∞–π–ª–∞ –ø–æ mimeType
          const isImage = attachment.mimeType && attachment.mimeType.startsWith('image/');
          
          if (isImage && attachment.data) {
            // –£–±–∏—Ä–∞–µ–º –ø—Ä–µ—Ñ–∏–∫—Å data:image/...;base64, –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å
            const base64Data = attachment.data.includes(',') 
              ? attachment.data.split(',')[1] 
              : attachment.data;
              
            formatted.content.push({
              type: 'image',
              source: {
                type: 'base64',
                media_type: attachment.mimeType,
                data: base64Data
              }
            });
          } else if (attachment.type === 'text' || attachment.mimeType?.startsWith('text/')) {
            // –î–ª—è —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Ñ–∞–π–ª–æ–≤ –¥–æ–±–∞–≤–ª—è–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –∫–∞–∫ —Ç–µ–∫—Å—Ç
            let content = attachment.content || '';
            
            // –ï—Å–ª–∏ –µ—Å—Ç—å data (base64), –ø—ã—Ç–∞–µ–º—Å—è –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å
            if (!content && attachment.data) {
              try {
                if (attachment.data.includes(',')) {
                  // data:text/plain;base64,xxxxx
                  const base64Data = attachment.data.split(',')[1];
                  content = Buffer.from(base64Data, 'base64').toString('utf-8');
                } else {
                  content = Buffer.from(attachment.data, 'base64').toString('utf-8');
                }
              } catch (e) {
                console.error('Failed to decode text file:', e);
                content = '[–ù–µ —É–¥–∞–ª–æ—Å—å –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–∞]';
              }
            }
            
            formatted.content.push({
              type: 'text',
              text: `üìÑ –§–∞–π–ª: ${attachment.name}\n\`\`\`\n${content || '[–§–∞–π–ª –ø—É—Å—Ç]'}\n\`\`\``
            });
          } else if (attachment.mimeType?.includes('json') || attachment.mimeType?.includes('xml') || 
                     attachment.mimeType?.includes('yaml') || attachment.mimeType?.includes('markdown')) {
            // –î–ª—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Ñ–∞–π–ª–æ–≤
            let content = '';
            
            if (attachment.data) {
              try {
                const base64Data = attachment.data.includes(',') 
                  ? attachment.data.split(',')[1] 
                  : attachment.data;
                content = Buffer.from(base64Data, 'base64').toString('utf-8');
              } catch (e) {
                console.error('Failed to decode file:', e);
              }
            }
            
            formatted.content.push({
              type: 'text',
              text: `üìÑ –§–∞–π–ª: ${attachment.name} (${attachment.mimeType})\n\`\`\`\n${content || '[–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å —Ñ–∞–π–ª]'}\n\`\`\``
            });
          } else {
            // –î–ª—è –¥—Ä—É–≥–∏—Ö —Ç–∏–ø–æ–≤ —Ñ–∞–π–ª–æ–≤ –¥–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ñ–∞–π–ª–µ
            formatted.content.push({
              type: 'text',
              text: `–ü—Ä–∏–∫—Ä–µ–ø–ª–µ–Ω —Ñ–∞–π–ª: ${attachment.name} (${attachment.mimeType || '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø'}, ${attachment.size ? Math.round(attachment.size / 1024) + ' KB' : '—Ä–∞–∑–º–µ—Ä –Ω–µ–∏–∑–≤–µ—Å—Ç–µ–Ω'})`
            });
          }
        }
      }

      return formatted;
    });
  }

  extractArtifacts(content) {
    const artifacts = [];
    
    // Extract code blocks
    const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
    let match;
    
    while ((match = codeBlockRegex.exec(content)) !== null) {
      artifacts.push({
        id: `artifact_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        type: 'code',
        language: match[1] || 'plain',
        content: match[2].trim()
      });
    }

    // Extract React components from Claude artifacts
    const reactRegex = /<function_calls>[\s\S]*?<invoke name="artifacts"[\s\S]*?type="application\/vnd\.ant\.react"[\s\S]*?<parameter name="content">([\s\S]*?)<\/antml:parameter>[\s\S]*?<\/antml:invoke>[\s\S]*?<\/antml:function_calls>/g;
    
    while ((match = reactRegex.exec(content)) !== null) {
      artifacts.push({
        id: `artifact_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        type: 'react',
        content: match[1].trim()
      });
    }
    
    // Extract SVG artifacts
    const svgRegex = /<function_calls>[\s\S]*?<invoke name="artifacts"[\s\S]*?type="image\/svg\+xml"[\s\S]*?<parameter name="content">([\s\S]*?)<\/antml:parameter>[\s\S]*?<\/antml:invoke>[\s\S]*?<\/antml:function_calls>/g;
    
    while ((match = svgRegex.exec(content)) !== null) {
      artifacts.push({
        id: `artifact_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        type: 'svg',
        content: match[1].trim()
      });
    }
    
    // Extract HTML artifacts
    const htmlRegex = /<function_calls>[\s\S]*?<invoke name="artifacts"[\s\S]*?type="text\/html"[\s\S]*?<parameter name="content">([\s\S]*?)<\/antml:parameter>[\s\S]*?<\/antml:invoke>[\s\S]*?<\/antml:function_calls>/g;
    
    while ((match = htmlRegex.exec(content)) !== null) {
      artifacts.push({
        id: `artifact_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        type: 'html',
        content: match[1].trim()
      });
    }

    return artifacts;
  }

  calculateCost(usage, model) {
    const pricing = {
      'claude-3.7-sonnet': { input: 0.003, output: 0.015 },
      'claude-4-sonnet': { input: 0.003, output: 0.015 },
      'claude-4-opus': { input: 0.015, output: 0.075 },
      // –î–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
      'claude-3.5-sonnet': { input: 0.003, output: 0.015 }
    };

    const modelPricing = pricing[model] || pricing['claude-3.7-sonnet'];
    
    const inputCost = (usage.promptTokens / 1000) * modelPricing.input;
    const outputCost = (usage.completionTokens / 1000) * modelPricing.output;
    
    return inputCost + outputCost;
  }

  async validateApiKey(apiKey) {
    try {
      const client = new Anthropic({ apiKey });
      
      // Try a minimal request
      await client.messages.create({
        model: 'claude-3-5-sonnet-20241022',
        messages: [{ role: 'user', content: 'Hi' }],
        max_tokens: 10
      });
      
      return true;
    } catch (error) {
      return false;
    }
  }
}

module.exports = new ClaudeService();