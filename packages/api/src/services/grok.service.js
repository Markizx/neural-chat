const axios = require('axios');
const logger = require('../utils/logger');

class GrokService {
  constructor() {
    this.apiKey = process.env.GROK_API_KEY;
    this.baseURL = 'https://api.x.ai/v1';
    
    // –°–æ–∑–¥–∞–µ–º axios instance
    this.client = axios.create({
      baseURL: this.baseURL,
      headers: {
        'Authorization': `Bearer ${this.apiKey}`,
        'Content-Type': 'application/json'
      },
      timeout: 60000 // 60 —Å–µ–∫—É–Ω–¥
    });
    
    // –ê–∫—Ç—É–∞–ª—å–Ω—ã–µ –º–æ–¥–µ–ª–∏ Grok
    this.models = {
      'grok-3': 'grok-3',
      'grok-3-mini': 'grok-3-mini',
      'grok-3-fast': 'grok-3-fast',
      'grok-3-mini-fast': 'grok-3-mini-fast',
      'grok-2': 'grok-2-1212',
      'grok-2-vision': 'grok-2-vision-1212',
      'grok-2-image': 'grok-2-image-1212', // –ú–æ–¥–µ–ª—å –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
      // –ê–ª–∏–∞—Å—ã –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
      'grok-2-1212': 'grok-2-1212',
      'grok-2-vision-1212': 'grok-2-vision-1212',
      'grok-2-image-1212': 'grok-2-image-1212'
    };

    // –¶–µ–Ω–æ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ —Å—Ç–æ–∏–º–æ—Å—Ç–∏
    this.pricing = {
      'grok-3': { input: 0.003, output: 0.015 }, // $3/$15 per 1M tokens
      'grok-3-mini': { input: 0.0003, output: 0.0005 }, // $0.30/$0.50 per 1M tokens
      'grok-3-fast': { input: 0.005, output: 0.025 }, // $5/$25 per 1M tokens
      'grok-3-mini-fast': { input: 0.0006, output: 0.004 }, // $0.60/$4 per 1M tokens
      'grok-2-1212': { input: 0.002, output: 0.01 }, // $2/$10 per 1M tokens
      'grok-2-vision-1212': { input: 0.002, output: 0.01 }, // $2/$10 per 1M tokens
      'grok-2-image-1212': { input: 0.002, output: 0.01 } // $2/$10 per 1M tokens
    };

    // –õ–∏–º–∏—Ç—ã –¥–ª—è –∫–∞–∂–¥–æ–π –º–æ–¥–µ–ª–∏
    this.rateLimits = {
      'grok-3': 10,
      'grok-3-mini': 10,
      'grok-3-fast': 10,
      'grok-3-mini-fast': 10,
      'grok-2-1212': 15,
      'grok-2-vision-1212': 10,
      'grok-2-image-1212': 10
    };

    // –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
    this.visionModels = ['grok-2-vision-1212', 'grok-2-vision'];
    
    // –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
    this.imageGenerationModels = ['grok-2-image-1212', 'grok-2-image'];
  }

  async createMessage(messages, options = {}) {
    try {
      const {
        model = 'grok-3',
        maxTokens = 4096,
        temperature = 0.7,
        systemPrompt = null,
        stream = false
      } = options;

      let modelId = this.models[model] || model;
      
      // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º –Ω–∞ vision –º–æ–¥–µ–ª—å –µ—Å–ª–∏ –µ—Å—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏ —Ç–µ–∫—É—â–∞—è –º–æ–¥–µ–ª—å –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∏—Ö
      const hasImages = messages.some(msg => 
        msg.attachments && msg.attachments.some(att => 
          att.mimeType && att.mimeType.startsWith('image/')
        )
      );
      
      if (hasImages && !this.supportsVision(modelId)) {
        console.log('üîÑ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º —Å', modelId, '–Ω–∞ grok-2-vision-1212 –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π');
        modelId = 'grok-2-vision-1212';
      }
      
      // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º –Ω–∞ image –º–æ–¥–µ–ª—å –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø—Ä–æ—Å–∏—Ç —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
      const lastUserMessage = messages.filter(msg => msg.role === 'user').pop();
      if (lastUserMessage && modelId !== 'grok-2-image-1212') {
        const imageGenerationKeywords = [
          '—Å–≥–µ–Ω–µ—Ä–∏—Ä—É', '—Å–æ–∑–¥–∞–π', '–Ω–∞—Ä–∏—Å—É–π', '–∏–∑–æ–±—Ä–∞–∑–∏', '–ø–æ–∫–∞–∂–∏',
          'generate', 'create', 'draw', 'show', 'make', 'design',
          '–∫–∞—Ä—Ç–∏–Ω', '–∏–∑–æ–±—Ä–∞–∂–µ–Ω', '–∏–ª–ª—é—Å—Ç—Ä–∞—Ü', '—Ä–∏—Å—É–Ω', '–≥—Ä–∞—Ñ',
          'image', 'picture', 'illustration', 'graphic', 'visual',
          '—Ñ–æ—Ç–æ', 'photo', '–∞—Ä—Ç', 'art'
        ];
        
        const requestsImageGeneration = imageGenerationKeywords.some(keyword => 
          lastUserMessage.content.toLowerCase().includes(keyword) && 
          (lastUserMessage.content.toLowerCase().includes('–∏–∑–æ–±—Ä–∞–∂') ||
           lastUserMessage.content.toLowerCase().includes('–∫–∞—Ä—Ç–∏–Ω') ||
           lastUserMessage.content.toLowerCase().includes('image') ||
           lastUserMessage.content.toLowerCase().includes('picture') ||
           lastUserMessage.content.toLowerCase().includes('—Ñ–æ—Ç–æ') ||
           lastUserMessage.content.toLowerCase().includes('—Ä–∏—Å—É–Ω'))
        );
        
        if (requestsImageGeneration) {
          console.log('üé® –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º —Å', modelId, '–Ω–∞ grok-2-image-1212 –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π');
          modelId = 'grok-2-image-1212';
        }
      }

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–µ –æ–∫–Ω–æ
      const contextSize = this.getContextSize(modelId);
      
      const requestBody = {
        model: modelId,
        messages: this.formatMessages(messages, systemPrompt, modelId),
        max_tokens: Math.min(maxTokens, contextSize),
        temperature,
        stream
      };

      if (stream) {
        // –î–ª—è streaming –∏—Å–ø–æ–ª—å–∑—É–µ–º –¥—Ä—É–≥–æ–π –ø–æ–¥—Ö–æ–¥
        const response = await this.client.post('/chat/completions', requestBody, {
          responseType: 'stream'
        });
        return response.data;
      }

      const response = await this.client.post('/chat/completions', requestBody);
      const data = response.data;

      return {
        content: data.choices[0].message.content,
        usage: {
          promptTokens: data.usage.prompt_tokens,
          completionTokens: data.usage.completion_tokens,
          totalTokens: data.usage.total_tokens
        },
        model: modelId,
        artifacts: this.extractArtifacts(data.choices[0].message.content)
      };
    } catch (error) {
      logger.error('Grok API error:', error);
      
      if (error.response) {
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –æ—Ç API
        const status = error.response.status;
        const errorData = error.response.data;
        
        if (status === 429) {
          const modelId = this.models[options.model] || options.model;
          throw new Error(`Rate limit exceeded for model ${modelId}. Limit: ${this.rateLimits[modelId]}rps`);
        }
        
        if (status === 401) {
          throw new Error('Invalid API key');
        }
        
        if (status === 400) {
          throw new Error(`Bad request: ${errorData.error?.message || 'Invalid request'}`);
        }
        
        throw new Error(`Grok API error: ${errorData.error?.message || error.message}`);
      } else if (error.request) {
        // –û—à–∏–±–∫–∞ —Å–µ—Ç–∏
        throw new Error('Network error: Unable to reach Grok API');
      } else {
        // –î—Ä—É–≥–∏–µ –æ—à–∏–±–∫–∏
        throw error;
      }
    }
  }

  async createStreamingMessage(messages, options = {}) {
    try {
      const stream = await this.createMessage(messages, { ...options, stream: true });
      return stream;
    } catch (error) {
      logger.error('Grok streaming error:', error);
      throw error;
    }
  }

  formatMessages(messages, systemPrompt, modelId) {
    const formattedMessages = [];
    
    // Add system prompt if provided
    if (systemPrompt) {
      formattedMessages.push({
        role: 'system',
        content: systemPrompt
      });
    }

    // Format user messages
    messages.forEach(msg => {
      const formatted = {
        role: msg.role === 'assistant' ? 'assistant' : 'user',
        content: []
      };

      // Add text content
      if (msg.content) {
        formatted.content.push({
          type: 'text',
          text: msg.content
        });
      }

      // Handle attachments for vision models
      if (msg.attachments && msg.attachments.length > 0 && this.supportsVision(modelId)) {
        console.log('üîç Grok processing attachments (vision):', {
          count: msg.attachments.length,
          modelId,
          attachments: msg.attachments.map(att => ({
            name: att.name,
            type: att.type || att.mimeType,
            size: att.size,
            hasData: !!att.data
          }))
        });
        
        msg.attachments.forEach(attachment => {
          const isImage = attachment.mimeType && attachment.mimeType.startsWith('image/');
          
          if (isImage && attachment.data) {
            // –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º –∫–∞–∫ data URL, —Ç–∞–∫ –∏ —á–∏—Å—Ç—ã–π base64
            const imageUrl = attachment.data.startsWith('data:') 
              ? attachment.data 
              : `data:${attachment.mimeType};base64,${attachment.data}`;
              
            formatted.content.push({
              type: 'image_url',
              image_url: {
                url: imageUrl,
                detail: 'auto'
              }
            });
          }
        });
      } else if (msg.attachments && msg.attachments.length > 0) {
        // For non-vision models, add attachment info as text
        console.log('üîç Grok processing attachments (non-vision):', {
          count: msg.attachments.length,
          modelId,
          attachments: msg.attachments.map(att => ({
            name: att.name,
            type: att.type || att.mimeType,
            size: att.size,
            hasData: !!att.data
          }))
        });
        
        const attachmentTexts = msg.attachments.map(att => {
          if (att.mimeType && att.mimeType.startsWith('image/')) {
            return `[–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ: ${att.name} (${att.mimeType}, ${att.size ? Math.round(att.size / 1024) + ' KB' : '—Ä–∞–∑–º–µ—Ä –Ω–µ–∏–∑–≤–µ—Å—Ç–µ–Ω'})]`;
          } else if (att.mimeType && att.mimeType.startsWith('text/')) {
            let content = att.content || '';
            
            // –ï—Å–ª–∏ –µ—Å—Ç—å data (base64), –ø—ã—Ç–∞–µ–º—Å—è –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å
            if (!content && att.data) {
              try {
                if (att.data.includes(',')) {
                  const base64Data = att.data.split(',')[1];
                  content = Buffer.from(base64Data, 'base64').toString('utf-8');
                } else {
                  content = Buffer.from(att.data, 'base64').toString('utf-8');
                }
              } catch (e) {
                console.error('Failed to decode text file:', e);
                content = '[–ù–µ —É–¥–∞–ª–æ—Å—å –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–∞]';
              }
            }
            
            return `üìÑ –§–∞–π–ª: ${att.name}\n\`\`\`\n${content || '[–§–∞–π–ª –ø—É—Å—Ç]'}\n\`\`\``;
          } else if (att.mimeType && (att.mimeType.includes('json') || att.mimeType.includes('xml') || 
                     att.mimeType.includes('yaml') || att.mimeType.includes('markdown'))) {
            let content = '';
            
            if (att.data) {
              try {
                const base64Data = att.data.includes(',') 
                  ? att.data.split(',')[1] 
                  : att.data;
                content = Buffer.from(base64Data, 'base64').toString('utf-8');
              } catch (e) {
                console.error('Failed to decode file:', e);
              }
            }
            
            return `üìÑ –§–∞–π–ª: ${att.name} (${att.mimeType})\n\`\`\`\n${content || '[–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å —Ñ–∞–π–ª]'}\n\`\`\``;
          } else {
            return `üìé –§–∞–π–ª: ${att.name} (${att.mimeType || '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø'}, ${att.size ? Math.round(att.size / 1024) + ' KB' : '—Ä–∞–∑–º–µ—Ä –Ω–µ–∏–∑–≤–µ—Å—Ç–µ–Ω'})`;
          }
        });
        
        if (attachmentTexts.length > 0) {
          formatted.content[0].text += '\n\n' + attachmentTexts.join('\n');
        }
      }

      // If content array has only one text item, simplify to string
      if (formatted.content.length === 1 && formatted.content[0].type === 'text') {
        formatted.content = formatted.content[0].text;
      }

      formattedMessages.push(formatted);
    });

    return formattedMessages;
  }

  extractArtifacts(content) {
    const artifacts = [];
    
    // Extract code blocks
    const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
    let match;
    
    while ((match = codeBlockRegex.exec(content)) !== null) {
      artifacts.push({
        id: `artifact_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        type: 'code',
        language: match[1] || 'plain',
        content: match[2].trim()
      });
    }
    
    // Extract generated images (–Ω–∞–ø—Ä–∏–º–µ—Ä: [Generated Image: description])
    const imageRegex = /\[Generated Image: ([^\]]+)\]/g;
    while ((match = imageRegex.exec(content)) !== null) {
      artifacts.push({
        id: `artifact_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        type: 'generated-image',
        description: match[1].trim(),
        // URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω API
      });
    }
    
    // Extract image URLs –≤ markdown —Ñ–æ—Ä–º–∞—Ç–µ
    const imageUrlRegex = /!\[([^\]]*)\]\(([^\)]+)\)/g;
    while ((match = imageUrlRegex.exec(content)) !== null) {
      artifacts.push({
        id: `artifact_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        type: 'image',
        alt: match[1].trim(),
        url: match[2].trim()
      });
    }

    return artifacts;
  }

  calculateCost(usage, model) {
    const modelId = this.models[model] || model;
    const pricing = this.pricing[modelId] || this.pricing['grok-3'];
    
    const inputCost = (usage.promptTokens / 1000) * pricing.input;
    const outputCost = (usage.completionTokens / 1000) * pricing.output;
    
    return inputCost + outputCost;
  }

  getContextSize(model) {
    const modelId = this.models[model] || model;
    
    // grok-2-vision has smaller context
    if (modelId === 'grok-2-vision-1212') {
      return 32768; // 32K tokens
    }
    
    // All other models support 131K tokens
    return 131072;
  }

  supportsVision(model) {
    const modelId = this.models[model] || model;
    return this.visionModels.includes(modelId);
  }

  supportsImageGeneration(model) {
    const modelId = this.models[model] || model;
    return this.imageGenerationModels.includes(modelId);
  }

  getRateLimit(model) {
    const modelId = this.models[model] || model;
    return this.rateLimits[modelId] || 10; // Default to 10 rps
  }

  async validateApiKey(apiKey) {
    try {
      const testClient = axios.create({
        baseURL: this.baseURL,
        headers: {
          'Authorization': `Bearer ${apiKey}`,
          'Content-Type': 'application/json'
        },
        timeout: 10000
      });

      await testClient.post('/chat/completions', {
        model: 'grok-3-mini', // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–∞–º—É—é –¥–µ—à–µ–≤—É—é –º–æ–¥–µ–ª—å –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
        messages: [{ role: 'user', content: 'Hi' }],
        max_tokens: 10
      });
      
      return true;
    } catch (error) {
      logger.error('API key validation failed:', error);
      return false;
    }
  }

  // –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π
  getAvailableModels() {
    return [
      {
        id: 'grok-3',
        name: 'Grok 3',
        description: 'Most capable model for complex tasks',
        contextSize: 131072,
        supportsVision: false,
        pricing: { input: '$3.00/1M', output: '$15.00/1M' },
        rateLimit: '10 rps'
      },
      {
        id: 'grok-3-mini',
        name: 'Grok 3 Mini',
        description: 'Efficient model for everyday tasks',
        contextSize: 131072,
        supportsVision: false,
        pricing: { input: '$0.30/1M', output: '$0.50/1M' },
        rateLimit: '10 rps'
      },
      {
        id: 'grok-3-fast',
        name: 'Grok 3 Fast',
        description: 'Fast responses for complex tasks',
        contextSize: 131072,
        supportsVision: false,
        pricing: { input: '$5.00/1M', output: '$25.00/1M' },
        rateLimit: '10 rps'
      },
      {
        id: 'grok-3-mini-fast',
        name: 'Grok 3 Mini Fast',
        description: 'Fast and efficient for quick tasks',
        contextSize: 131072,
        supportsVision: false,
        pricing: { input: '$0.60/1M', output: '$4.00/1M' },
        rateLimit: '10 rps'
      },
      {
        id: 'grok-2',
        name: 'Grok 2',
        description: 'Previous generation model',
        contextSize: 131072,
        supportsVision: false,
        pricing: { input: '$2.00/1M', output: '$10.00/1M' },
        rateLimit: '15 rps'
      },
      {
        id: 'grok-2-vision',
        name: 'Grok 2 Vision',
        description: 'Multimodal model with image understanding',
        contextSize: 32768,
        supportsVision: true,
        pricing: { input: '$2.00/1M', output: '$10.00/1M', image: '$2.00/1M' },
        rateLimit: '10 rps'
      },
      {
        id: 'grok-2-image',
        name: 'Grok 2 Image',
        description: 'Model for image generation',
        contextSize: 131072,
        supportsImageGeneration: true,
        pricing: { input: '$2.00/1M', output: '$10.00/1M' },
        rateLimit: '10 rps'
      }
    ];
  }

  // –û—Ü–µ–Ω–∫–∞ —Å—Ç–æ–∏–º–æ—Å—Ç–∏ –¥–æ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∑–∞–ø—Ä–æ—Å–∞
  estimateCost(messages, model = 'grok-3') {
    const modelId = this.models[model] || model;
    const pricing = this.pricing[modelId] || this.pricing['grok-3'];
    
    // –ì—Ä—É–±–∞—è –æ—Ü–µ–Ω–∫–∞ —Ç–æ–∫–µ–Ω–æ–≤
    let estimatedInputTokens = 0;
    
    messages.forEach(msg => {
      // –ü—Ä–∏–º–µ—Ä–Ω–æ 4 —Å–∏–º–≤–æ–ª–∞ –Ω–∞ —Ç–æ–∫–µ–Ω
      if (typeof msg.content === 'string') {
        estimatedInputTokens += Math.ceil(msg.content.length / 4);
      } else if (Array.isArray(msg.content)) {
        msg.content.forEach(item => {
          if (item.type === 'text') {
            estimatedInputTokens += Math.ceil(item.text.length / 4);
          } else if (item.type === 'image_url' && this.supportsVision(modelId)) {
            // –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –æ–±—ã—á–Ω–æ –∑–∞–Ω–∏–º–∞—é—Ç –æ–∫–æ–ª–æ 765 —Ç–æ–∫–µ–Ω–æ–≤
            estimatedInputTokens += 765;
          }
        });
      }
    });
    
    // –ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ –æ—Ç–≤–µ—Ç –±—É–¥–µ—Ç –ø—Ä–∏–º–µ—Ä–Ω–æ —Ç–∞–∫–æ–π –∂–µ –¥–ª–∏–Ω—ã
    const estimatedOutputTokens = Math.min(estimatedInputTokens, 2048);
    
    const estimatedInputCost = (estimatedInputTokens / 1000) * pricing.input;
    const estimatedOutputCost = (estimatedOutputTokens / 1000) * pricing.output;
    
    return {
      estimatedInputTokens,
      estimatedOutputTokens,
      estimatedTotalTokens: estimatedInputTokens + estimatedOutputTokens,
      estimatedCost: estimatedInputCost + estimatedOutputCost,
      breakdown: {
        input: estimatedInputCost,
        output: estimatedOutputCost
      }
    };
  }

  // –ú–µ—Ç–æ–¥ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ streaming –æ—Ç–≤–µ—Ç–æ–≤
  async *streamResponse(stream) {
    try {
      for await (const chunk of stream) {
        const lines = chunk.toString().split('\n').filter(line => line.trim() !== '');
        
        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = line.substring(6);
            
            if (data === '[DONE]') {
              return;
            }
            
            try {
              const parsed = JSON.parse(data);
              yield parsed;
            } catch (e) {
              logger.error('Error parsing stream chunk:', e);
            }
          }
        }
      }
    } catch (error) {
      logger.error('Stream processing error:', error);
      throw error;
    }
  }
}

module.exports = new GrokService();