const axios = require('axios');
const logger = require('../utils/logger');

class GrokService {
  constructor() {
    this.apiKey = process.env.GROK_API_KEY;
    this.baseURL = 'https://api.x.ai/v1';
    
    // –°–æ–∑–¥–∞–µ–º axios instance
    this.client = axios.create({
      baseURL: this.baseURL,
      headers: {
        'Authorization': `Bearer ${this.apiKey}`,
        'Content-Type': 'application/json'
      },
      timeout: 60000 // 60 —Å–µ–∫—É–Ω–¥
    });
    
    // –ê–∫—Ç—É–∞–ª—å–Ω—ã–µ –º–æ–¥–µ–ª–∏ Grok (—Å—Ç–∞–Ω–¥–∞—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ)
    this.models = {
      'grok-2-1212': 'grok-2-1212',
      'grok-2-vision-1212': 'grok-2-vision-1212',
      'aurora': 'aurora' // –î–æ–±–∞–≤–ª—è–µ–º –º–æ–¥–µ–ª—å Aurora –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
    };

    // –¶–µ–Ω–æ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ —Å—Ç–æ–∏–º–æ—Å—Ç–∏ (—Å—Ç–∞–Ω–¥–∞—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –º–æ–¥–µ–ª–∏)
    this.pricing = {
      'grok-2-1212': { input: 0.002, output: 0.01 }, // $2/$10 per 1M tokens
      'grok-2-vision-1212': { input: 0.005, output: 0.015 }, // $5/$15 per 1M tokens
      'aurora': { input: 0.002, output: 0.01 } // –¶–µ–Ω–æ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –¥–ª—è Aurora
    };

    // –õ–∏–º–∏—Ç—ã –¥–ª—è –∫–∞–∂–¥–æ–π –º–æ–¥–µ–ª–∏ (—Å—Ç–∞–Ω–¥–∞—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ)
    this.rateLimits = {
      'grok-2-1212': 15,
      'grok-2-vision-1212': 10,
      'aurora': 10
    };

    // –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
    this.visionModels = ['grok-2-vision-1212', 'grok-2-vision'];
    
    // –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
    this.imageGenerationModels = ['grok-2-image-1212', 'grok-2-image', 'aurora'];
  }

  async createMessage(messages, options = {}) {
    try {
      const {
        model = 'grok-2-1212',
        maxTokens = 4096,
        temperature = 0.7,
        systemPrompt = null,
        stream = false
      } = options;

      let modelId = this.models[model] || model;
      
      // –ï—Å–ª–∏ —ç—Ç–æ –º–æ–¥–µ–ª—å Aurora, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–ø–µ—Ü–∏–∞–ª—å–Ω—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
      if (modelId === 'aurora') {
        const lastUserMessage = messages.filter(msg => msg.role === 'user').pop();
        if (!lastUserMessage) {
          throw new Error('No user message found for image generation');
        }
        return await this.generateImage(lastUserMessage.content);
      }
      
      // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º –Ω–∞ vision –º–æ–¥–µ–ª—å –µ—Å–ª–∏ –µ—Å—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏ —Ç–µ–∫—É—â–∞—è –º–æ–¥–µ–ª—å –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∏—Ö
      const hasImages = messages.some(msg => 
        msg.attachments && msg.attachments.some(att => 
          att.mimeType && att.mimeType.startsWith('image/')
        )
      );
      
      if (hasImages && !this.supportsVision(modelId)) {
        console.log('üîÑ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º —Å', modelId, '–Ω–∞ grok-2-vision-1212 –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π');
        modelId = 'grok-2-vision-1212';
      }
      
      // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º –Ω–∞ image –º–æ–¥–µ–ª—å –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø—Ä–æ—Å–∏—Ç —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
      const lastUserMessage = messages.filter(msg => msg.role === 'user').pop();
      if (lastUserMessage && !this.supportsImageGeneration(modelId)) {
        const imageGenerationKeywords = [
          '—Å–≥–µ–Ω–µ—Ä–∏—Ä—É', '—Å–æ–∑–¥–∞–π', '–Ω–∞—Ä–∏—Å—É–π', '–∏–∑–æ–±—Ä–∞–∑–∏', '–ø–æ–∫–∞–∂–∏',
          'generate', 'create', 'draw', 'show', 'make', 'design',
          '–∫–∞—Ä—Ç–∏–Ω', '–∏–∑–æ–±—Ä–∞–∂–µ–Ω', '–∏–ª–ª—é—Å—Ç—Ä–∞—Ü', '—Ä–∏—Å—É–Ω', '–≥—Ä–∞—Ñ',
          'image', 'picture', 'illustration', 'graphic', 'visual',
          '—Ñ–æ—Ç–æ', 'photo', '–∞—Ä—Ç', 'art'
        ];
        
        const requestsImageGeneration = imageGenerationKeywords.some(keyword => 
          lastUserMessage.content.toLowerCase().includes(keyword)
        ) || (lastUserMessage.content.toLowerCase().includes('–∏–∑–æ–±—Ä–∞–∂') ||
           lastUserMessage.content.toLowerCase().includes('–∫–∞—Ä—Ç–∏–Ω') ||
           lastUserMessage.content.toLowerCase().includes('image') ||
           lastUserMessage.content.toLowerCase().includes('picture') ||
           lastUserMessage.content.toLowerCase().includes('—Ñ–æ—Ç–æ') ||
           lastUserMessage.content.toLowerCase().includes('—Ä–∏—Å—É–Ω'));
        
        if (requestsImageGeneration) {
          console.log('üé® –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º —Å', modelId, '–Ω–∞ aurora –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π');
          modelId = 'aurora';
        }
      }

      // –ï—Å–ª–∏ –ø–æ—Å–ª–µ –∞–≤—Ç–æ–ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è –ø–æ–ª—É—á–∏–ª–∏ aurora, —Å—Ä–∞–∑—É –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
      if (modelId === 'aurora') {
        const lastUserMessage = messages.filter(msg => msg.role === 'user').pop();
        if (!lastUserMessage) {
          throw new Error('No user message found for image generation');
        }
        return await this.generateImage(lastUserMessage.content);
      }

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–µ –æ–∫–Ω–æ
      const contextSize = this.getContextSize(modelId);
      
      const requestBody = {
        model: modelId,
        messages: this.formatMessages(messages, systemPrompt, modelId),
        max_tokens: Math.min(maxTokens, contextSize),
        temperature,
        stream
      };

      if (stream) {
        // –î–ª—è streaming –∏—Å–ø–æ–ª—å–∑—É–µ–º –¥—Ä—É–≥–æ–π –ø–æ–¥—Ö–æ–¥
        const response = await this.client.post('/chat/completions', requestBody, {
          responseType: 'stream'
        });
        return response.data;
      }

      const response = await this.client.post('/chat/completions', requestBody);
      const data = response.data;

      return {
        content: data.choices[0].message.content,
        usage: {
          promptTokens: data.usage.prompt_tokens,
          completionTokens: data.usage.completion_tokens,
          totalTokens: data.usage.total_tokens
        },
        model: modelId,
        artifacts: this.extractArtifacts(data.choices[0].message.content)
      };
    } catch (error) {
      logger.error('Grok API error:', error);
      
      if (error.response) {
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –æ—Ç API
        const status = error.response.status;
        const errorData = error.response.data;
        
        if (status === 429) {
          const modelId = this.models[options.model] || options.model;
          throw new Error(`Rate limit exceeded for model ${modelId}. Limit: ${this.rateLimits[modelId]}rps`);
        }
        
        if (status === 401) {
          throw new Error('Invalid API key');
        }
        
        if (status === 400) {
          throw new Error(`Bad request: ${errorData.error?.message || 'Invalid request'}`);
        }
        
        throw new Error(`Grok API error: ${errorData.error?.message || error.message}`);
      } else if (error.request) {
        // –û—à–∏–±–∫–∞ —Å–µ—Ç–∏
        throw new Error('Network error: Unable to reach Grok API');
      } else {
        // –î—Ä—É–≥–∏–µ –æ—à–∏–±–∫–∏
        throw error;
      }
    }
  }

  async createStreamingMessage(messages, options = {}) {
    try {
      const stream = await this.createMessage(messages, { ...options, stream: true });
      return stream;
    } catch (error) {
      logger.error('Grok streaming error:', error);
      throw error;
    }
  }

  async generateImage(prompt) {
    try {
      logger.info(`üé® –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ Grok –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è, prompt: ${prompt.substring(0, 50)}...`);
      
      // –î–µ–ª–∞–µ–º –∑–∞–ø—Ä–æ—Å –∫ X.AI API –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
      const requestBody = {
        prompt: prompt,
        model: 'grok-2-image',
        response_format: 'url',
        n: 1
      };

      const response = await axios.post('https://api.x.ai/v1/images/generations', requestBody, {
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json'
        },
        timeout: 60000 // 60 —Å–µ–∫—É–Ω–¥ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
      });
      
      if (!response.data?.data?.[0]?.url) {
        logger.error('Grok API response structure:', JSON.stringify(response.data, null, 2));
        throw new Error('Grok API –Ω–µ –≤–µ—Ä–Ω—É–ª URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è');
      }
      
      const imageUrl = response.data.data[0].url;
      logger.info(`üñºÔ∏è –ü–æ–ª—É—á–µ–Ω URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: ${imageUrl}`);
      
      // –õ–æ–≥–∏—Ä—É–µ–º –ø–æ–ª—É—á–µ–Ω–Ω—ã–π –ø—Ä–æ–º–ø—Ç (–µ—Å–ª–∏ –µ—Å—Ç—å)
      if (response.data.data[0].revised_prompt) {
        logger.info(`Grok –ø–µ—Ä–µ—Ä–∞–±–æ—Ç–∞–ª –ø—Ä–æ–º–ø—Ç: ${response.data.data[0].revised_prompt.substring(0, 100)}`);
      }

      const artifactId = `artifact_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      logger.info(`üé® –°–æ–∑–¥–∞–µ–º artifact –¥–ª—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: ${artifactId}, URL: ${imageUrl}`);
      
      return { 
        content: `–ö–æ–Ω–µ—á–Ω–æ! –í–æ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ: ${prompt}

![Generated Image](${imageUrl})

–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –±—ã–ª–æ —É—Å–ø–µ—à–Ω–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ —Å –ø–æ–º–æ—â—å—é –º–æ–¥–µ–ª–∏ Grok 2 Image.`,
        imageUrl, 
        generator: 'grok-2-image', 
        quality: 'hd',
        revisedPrompt: response.data.data[0].revised_prompt,
        usage: {
          promptTokens: Math.ceil(prompt.length / 4),
          completionTokens: 50,
          totalTokens: Math.ceil(prompt.length / 4) + 50
        },
        model: 'aurora',
        artifacts: [
          {
            id: artifactId,
            type: 'generated-image',
            url: imageUrl,
            description: prompt,
            revisedPrompt: response.data.data[0].revised_prompt
          }
        ]
      };
    } catch (error) {
      logger.error('Grok image generation error:', error);
      
      // –ï—Å–ª–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–µ–∫—Å—Ç–æ–≤—ã–π –æ—Ç–≤–µ—Ç
      if (error.response?.status === 400 || error.response?.data?.error?.code === 'unsupported_model') {
        logger.warn('Grok image generation –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–µ–∫—Å—Ç–æ–≤—ã–π –æ—Ç–≤–µ—Ç');
        return {
          content: `–ò–∑–≤–∏–Ω–∏—Ç–µ, —è –Ω–µ –º–æ–≥—É –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç. –ù–æ —è –º–æ–≥—É –ø–æ–¥—Ä–æ–±–Ω–æ –æ–ø–∏—Å–∞—Ç—å, –∫–∞–∫ –±—ã –≤—ã–≥–ª—è–¥–µ–ª–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ: "${prompt}"

–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥—Ä—É–≥—É—é –º–æ–¥–µ–ª—å –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.`,
          generator: 'grok-text-fallback',
          usage: {
            promptTokens: Math.ceil(prompt.length / 4),
            completionTokens: 100,
            totalTokens: Math.ceil(prompt.length / 4) + 100
          },
          model: 'aurora'
        };
      }
      
      throw error;
    }
  }

  extractImageDescription(userMessage) {
    // –ò–∑–≤–ª–µ–∫–∞–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–∑ –∑–∞–ø—Ä–æ—Å–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const lowerMessage = userMessage.toLowerCase();
    
    // –ò—â–µ–º –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
    if (lowerMessage.includes('bmw') && lowerMessage.includes('e60') && lowerMessage.includes('m5')) {
      return 'BMW E60 M5 —è—Ä–∫–æ-–∫—Ä–∞—Å–Ω–æ–≥–æ —Ü–≤–µ—Ç–∞';
    }
    
    // –£–±–∏—Ä–∞–µ–º —Å–ª–æ–≤–∞-–∫–æ–º–∞–Ω–¥—ã –∏ –æ—Å—Ç–∞–≤–ª—è–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ
    const cleanedMessage = userMessage
      .replace(/—Å–≥–µ–Ω–µ—Ä–∏—Ä—É[–π–∂]?|—Å–æ–∑–¥–∞–π|–Ω–∞—Ä–∏—Å—É–π|–∏–∑–æ–±—Ä–∞–∑–∏|–ø–æ–∫–∞–∂–∏/gi, '')
      .replace(/generate|create|draw|show|make/gi, '')
      .replace(/–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ|–∫–∞—Ä—Ç–∏–Ω–∫—É|—Ñ–æ—Ç–æ|—Ä–∏—Å—É–Ω–æ–∫/gi, '')
      .replace(/image|picture|photo/gi, '')
      .trim();
    
    return cleanedMessage || '–∑–∞–ø—Ä–æ—à–µ–Ω–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ';
  }

  async getChatResponse(messages) {
    try {
      logger.info('ü§ñ –û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –≤ Grok AI –¥–ª—è —á–∞—Ç–∞');
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏ —Ñ–∏–ª—å—Ç—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è
      const validMessages = messages.filter(msg => msg && msg.content && msg.content.trim().length > 0);
      
      if (validMessages.length === 0) {
        throw new Error('–ù–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏');
      }
      
      // –î–æ–±–∞–≤–ª—è–µ–º —Å–∏—Å—Ç–µ–º–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –µ—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç
      const messagesWithSystem = validMessages[0]?.role === 'system' 
        ? validMessages 
        : [
            {
              role: 'system',
              content: 'You are a helpful AI assistant. Respond in the same language as the user\'s messages.'
            },
            ...validMessages
          ];
      
      const requestBody = {
        messages: messagesWithSystem,
        model: 'grok-3', // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–∞–º—É—é –º–æ—â–Ω—É—é –º–æ–¥–µ–ª—å Grok-3
        max_tokens: 2000,
        temperature: 0.7,
        stream: false
      };

      const response = await axios.post('https://api.x.ai/v1/chat/completions', requestBody, {
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json'
        },
        timeout: 30000
      });

      const aiResponse = response.data?.choices?.[0]?.message?.content;
      if (!aiResponse) {
        throw new Error('Grok AI –Ω–µ –≤–µ—Ä–Ω—É–ª –æ—Ç–≤–µ—Ç');
      }
      
      return {
        content: aiResponse,
        usage: response.data.usage,
        model: 'grok-3'
      };
    } catch (error) {
      logger.error('Grok chat error:', error);
      
      // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ API
      if (error.response) {
        const status = error.response.status;
        const errorData = error.response.data;
        
        if (status === 429) {
          throw new Error(`Rate limit exceeded for Grok chat`);
        }
        
        if (status === 401) {
          throw new Error('Invalid Grok API key');
        }
        
        if (status === 400) {
          throw new Error(`Bad request: ${errorData.error?.message || 'Invalid request'}`);
        }
        
        throw new Error(`Grok API error: ${errorData.error?.message || error.message}`);
      }
      
      throw error;
    }
  }

  formatMessages(messages, systemPrompt, modelId) {
    const formattedMessages = [];
    
    // Add system prompt if provided
    if (systemPrompt) {
      formattedMessages.push({
        role: 'system',
        content: systemPrompt
      });
    }

    // Format user messages
    messages.forEach(msg => {
      const formatted = {
        role: msg.role === 'assistant' ? 'assistant' : 'user',
        content: []
      };

      // Add text content
      if (msg.content) {
        formatted.content.push({
          type: 'text',
          text: msg.content
        });
      }

      // Handle attachments for vision models
      if (msg.attachments && msg.attachments.length > 0 && this.supportsVision(modelId)) {
        console.log('üîç Grok processing attachments (vision):', {
          count: msg.attachments.length,
          modelId,
          attachments: msg.attachments.map(att => ({
            name: att.name,
            type: att.type || att.mimeType,
            size: att.size,
            hasData: !!att.data
          }))
        });
        
        msg.attachments.forEach(attachment => {
          const isImage = attachment.mimeType && attachment.mimeType.startsWith('image/');
          
          if (isImage && attachment.data) {
            // –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º –∫–∞–∫ data URL, —Ç–∞–∫ –∏ —á–∏—Å—Ç—ã–π base64
            const imageUrl = attachment.data.startsWith('data:') 
              ? attachment.data 
              : `data:${attachment.mimeType};base64,${attachment.data}`;
              
            formatted.content.push({
              type: 'image_url',
              image_url: {
                url: imageUrl,
                detail: 'auto'
              }
            });
          }
        });
      } else if (msg.attachments && msg.attachments.length > 0) {
        // For non-vision models, add attachment info as text
        console.log('üîç Grok processing attachments (non-vision):', {
          count: msg.attachments.length,
          modelId,
          attachments: msg.attachments.map(att => ({
            name: att.name,
            type: att.type || att.mimeType,
            size: att.size,
            hasData: !!att.data
          }))
        });
        
        const attachmentTexts = msg.attachments.map(att => {
          if (att.mimeType && att.mimeType.startsWith('image/')) {
            return `[–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ: ${att.name} (${att.mimeType}, ${att.size ? Math.round(att.size / 1024) + ' KB' : '—Ä–∞–∑–º–µ—Ä –Ω–µ–∏–∑–≤–µ—Å—Ç–µ–Ω'})]`;
          } else if (att.mimeType && att.mimeType.startsWith('text/')) {
            let content = att.content || '';
            
            // –ï—Å–ª–∏ –µ—Å—Ç—å data (base64), –ø—ã—Ç–∞–µ–º—Å—è –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å
            if (!content && att.data) {
              try {
                if (att.data.includes(',')) {
                  const base64Data = att.data.split(',')[1];
                  content = Buffer.from(base64Data, 'base64').toString('utf-8');
                } else {
                  content = Buffer.from(att.data, 'base64').toString('utf-8');
                }
              } catch (e) {
                console.error('Failed to decode text file:', e);
                content = '[–ù–µ —É–¥–∞–ª–æ—Å—å –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–∞]';
              }
            }
            
            return `üìÑ –§–∞–π–ª: ${att.name}\n\`\`\`\n${content || '[–§–∞–π–ª –ø—É—Å—Ç]'}\n\`\`\``;
          } else if (att.mimeType && (att.mimeType.includes('json') || att.mimeType.includes('xml') || 
                     att.mimeType.includes('yaml') || att.mimeType.includes('markdown'))) {
            let content = '';
            
            if (att.data) {
              try {
                const base64Data = att.data.includes(',') 
                  ? att.data.split(',')[1] 
                  : att.data;
                content = Buffer.from(base64Data, 'base64').toString('utf-8');
              } catch (e) {
                console.error('Failed to decode file:', e);
              }
            }
            
            return `üìÑ –§–∞–π–ª: ${att.name} (${att.mimeType})\n\`\`\`\n${content || '[–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å —Ñ–∞–π–ª]'}\n\`\`\``;
          } else {
            return `üìé –§–∞–π–ª: ${att.name} (${att.mimeType || '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø'}, ${att.size ? Math.round(att.size / 1024) + ' KB' : '—Ä–∞–∑–º–µ—Ä –Ω–µ–∏–∑–≤–µ—Å—Ç–µ–Ω'})`;
          }
        });
        
        if (attachmentTexts.length > 0) {
          formatted.content[0].text += '\n\n' + attachmentTexts.join('\n');
        }
      }

      // If content array has only one text item, simplify to string
      if (formatted.content.length === 1 && formatted.content[0].type === 'text') {
        formatted.content = formatted.content[0].text;
      }

      formattedMessages.push(formatted);
    });

    return formattedMessages;
  }

  extractArtifacts(content) {
    const artifacts = [];
    
    // Extract code blocks
    const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
    let match;
    
    while ((match = codeBlockRegex.exec(content)) !== null) {
      artifacts.push({
        id: `artifact_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        type: 'code',
        language: match[1] || 'plain',
        content: match[2].trim()
      });
    }
    
    // Extract generated images (–Ω–∞–ø—Ä–∏–º–µ—Ä: [Generated Image: description])
    const imageRegex = /\[Generated Image: ([^\]]+)\]/g;
    while ((match = imageRegex.exec(content)) !== null) {
      artifacts.push({
        id: `artifact_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        type: 'generated-image',
        description: match[1].trim(),
        // URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω API
      });
    }
    
    // Extract image URLs –≤ markdown —Ñ–æ—Ä–º–∞—Ç–µ
    const imageUrlRegex = /!\[([^\]]*)\]\(([^\)]+)\)/g;
    while ((match = imageUrlRegex.exec(content)) !== null) {
      artifacts.push({
        id: `artifact_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        type: 'image',
        alt: match[1].trim(),
        url: match[2].trim()
      });
    }

    return artifacts;
  }

  calculateCost(usage, model) {
    const modelId = this.models[model] || model;
    const pricing = this.pricing[modelId] || this.pricing['grok-2-1212'];
    
    const inputCost = (usage.promptTokens / 1000) * pricing.input;
    const outputCost = (usage.completionTokens / 1000) * pricing.output;
    
    return inputCost + outputCost;
  }

  getContextSize(model) {
    const modelId = this.models[model] || model;
    
    // grok-2-vision has smaller context
    if (modelId === 'grok-2-vision-1212') {
      return 32768; // 32K tokens
    }
    
    // All other models support 131K tokens
    return 131072;
  }

  supportsVision(model) {
    const modelId = this.models[model] || model;
    return this.visionModels.includes(modelId);
  }

  supportsImageGeneration(model) {
    const modelId = this.models[model] || model;
    return this.imageGenerationModels.includes(modelId);
  }

  getRateLimit(model) {
    const modelId = this.models[model] || model;
    return this.rateLimits[modelId] || 10; // Default to 10 rps
  }

  async validateApiKey(apiKey) {
    try {
      const testClient = axios.create({
        baseURL: this.baseURL,
        headers: {
          'Authorization': `Bearer ${apiKey}`,
          'Content-Type': 'application/json'
        },
        timeout: 10000
      });

      await testClient.post('/chat/completions', {
        model: 'grok-3-mini', // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–∞–º—É—é –¥–µ—à–µ–≤—É—é –º–æ–¥–µ–ª—å –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
        messages: [{ role: 'user', content: 'Hi' }],
        max_tokens: 10
      });
      
      return true;
    } catch (error) {
      logger.error('API key validation failed:', error);
      return false;
    }
  }

  // –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π
  getAvailableModels() {
    return [
      {
        id: 'grok-3',
        name: 'Grok 3',
        description: 'Most capable model for complex tasks',
        contextSize: 131072,
        supportsVision: false,
        pricing: { input: '$3.00/1M', output: '$15.00/1M' },
        rateLimit: '10 rps'
      },
      {
        id: 'grok-3-mini',
        name: 'Grok 3 Mini',
        description: 'Efficient model for everyday tasks',
        contextSize: 131072,
        supportsVision: false,
        pricing: { input: '$0.30/1M', output: '$0.50/1M' },
        rateLimit: '10 rps'
      },
      {
        id: 'grok-3-fast',
        name: 'Grok 3 Fast',
        description: 'Fast responses for complex tasks',
        contextSize: 131072,
        supportsVision: false,
        pricing: { input: '$5.00/1M', output: '$25.00/1M' },
        rateLimit: '10 rps'
      },
      {
        id: 'grok-3-mini-fast',
        name: 'Grok 3 Mini Fast',
        description: 'Fast and efficient for quick tasks',
        contextSize: 131072,
        supportsVision: false,
        pricing: { input: '$0.60/1M', output: '$4.00/1M' },
        rateLimit: '10 rps'
      },
      {
        id: 'grok-2',
        name: 'Grok 2',
        description: 'Previous generation model',
        contextSize: 131072,
        supportsVision: false,
        pricing: { input: '$2.00/1M', output: '$10.00/1M' },
        rateLimit: '15 rps'
      },
      {
        id: 'grok-2-vision',
        name: 'Grok 2 Vision',
        description: 'Multimodal model with image understanding',
        contextSize: 32768,
        supportsVision: true,
        pricing: { input: '$2.00/1M', output: '$10.00/1M', image: '$2.00/1M' },
        rateLimit: '10 rps'
      },
      {
        id: 'grok-2-image',
        name: 'Grok 2 Image (Aurora)',
        description: 'Model for image generation powered by Aurora',
        contextSize: 131072,
        supportsImageGeneration: true,
        pricing: { input: '$2.00/1M', output: '$10.00/1M' },
        rateLimit: '10 rps'
      }
    ];
  }

  // –û—Ü–µ–Ω–∫–∞ —Å—Ç–æ–∏–º–æ—Å—Ç–∏ –¥–æ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∑–∞–ø—Ä–æ—Å–∞
  estimateCost(messages, model = 'grok-2-1212') {
    const modelId = this.models[model] || model;
    const pricing = this.pricing[modelId] || this.pricing['grok-2-1212'];
    
    // –ì—Ä—É–±–∞—è –æ—Ü–µ–Ω–∫–∞ —Ç–æ–∫–µ–Ω–æ–≤
    let estimatedInputTokens = 0;
    
    messages.forEach(msg => {
      // –ü—Ä–∏–º–µ—Ä–Ω–æ 4 —Å–∏–º–≤–æ–ª–∞ –Ω–∞ —Ç–æ–∫–µ–Ω
      if (typeof msg.content === 'string') {
        estimatedInputTokens += Math.ceil(msg.content.length / 4);
      } else if (Array.isArray(msg.content)) {
        msg.content.forEach(item => {
          if (item.type === 'text') {
            estimatedInputTokens += Math.ceil(item.text.length / 4);
          } else if (item.type === 'image_url' && this.supportsVision(modelId)) {
            // –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –æ–±—ã—á–Ω–æ –∑–∞–Ω–∏–º–∞—é—Ç –æ–∫–æ–ª–æ 765 —Ç–æ–∫–µ–Ω–æ–≤
            estimatedInputTokens += 765;
          }
        });
      }
    });
    
    // –ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ –æ—Ç–≤–µ—Ç –±—É–¥–µ—Ç –ø—Ä–∏–º–µ—Ä–Ω–æ —Ç–∞–∫–æ–π –∂–µ –¥–ª–∏–Ω—ã
    const estimatedOutputTokens = Math.min(estimatedInputTokens, 2048);
    
    const estimatedInputCost = (estimatedInputTokens / 1000) * pricing.input;
    const estimatedOutputCost = (estimatedOutputTokens / 1000) * pricing.output;
    
    return {
      estimatedInputTokens,
      estimatedOutputTokens,
      estimatedTotalTokens: estimatedInputTokens + estimatedOutputTokens,
      estimatedCost: estimatedInputCost + estimatedOutputCost,
      breakdown: {
        input: estimatedInputCost,
        output: estimatedOutputCost
      }
    };
  }

  // –ú–µ—Ç–æ–¥ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ streaming –æ—Ç–≤–µ—Ç–æ–≤
  async *streamResponse(stream) {
    try {
      for await (const chunk of stream) {
        const lines = chunk.toString().split('\n').filter(line => line.trim() !== '');
        
        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = line.substring(6);
            
            if (data === '[DONE]') {
              return;
            }
            
            try {
              const parsed = JSON.parse(data);
              yield parsed;
            } catch (e) {
              logger.error('Error parsing stream chunk:', e);
            }
          }
        }
      }
    } catch (error) {
      logger.error('Stream processing error:', error);
      throw error;
    }
  }
}

module.exports = new GrokService();